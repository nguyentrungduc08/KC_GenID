// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <bits/stdc++.h>
#include "KC_GenID.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>  
#include <thrift/transport/TServerSocket.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>

#include "Poco/Util/Application.h"
#include "Poco/Util/Option.h"
#include "Poco/Util/OptionSet.h"
#include "Poco/Util/HelpFormatter.h"
#include "Poco/Util/AbstractConfiguration.h"

#include "Poco/Notification.h"
#include "Poco/NotificationQueue.h"
#include "Poco/ThreadPool.h"
#include "Poco/Runnable.h"
#include "Poco/AutoPtr.h"

//Kyoto Cabinet database
#include <kchashdb.h>
#include <thrift/TToString.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;
using namespace kyotocabinet;
using namespace  ::KC_GenID;

using Poco::Util::Application;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::HelpFormatter;
using Poco::Util::AbstractConfiguration;
using Poco::Util::OptionCallback;

class KC_GenIDHandler : virtual public KC_GenIDIf {
private:
    HashDB db;
public:
    KC_GenIDHandler() {
        // Your initialization goes here
        // Your initialization goes here
        std::cout << "Server Starting........." <<std::endl;
        std::cout << std::endl;
        
        if (db.open("dbID.kch", HashDB::OWRITER | HashDB::OCREATE)) {
            std::cout << "open KC database success" << std::endl; 
        } else {
            std::cerr << "open error: " << db.error().name() << std::endl; 
        }
    }
    
    ~KC_GenIDHandler() {
        if (db.close()) {
            std::cout << "close KC database success" << std::endl;
        } else {
            std::cerr << "close error: " << db.error().name() << std::endl;
        }
    }

    void genId(Z_idGen& _return, const std::string& idType) {
        // Your implementation goes here
        int32_t isExistKey =  this->db.check(idType);
        if (isExistKey < 0){
            int64_t id = 1;
            std::string sId = std::to_string(id);
            this->db.set(idType,sId);
            KC_GenID::Z_idGen result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        } else {
            int64_t id;
            std::string sId;
            this->db.get(idType, &sId);
            id = std::stoi(sId);
            ++id;
            sId = std::to_string(id);
            this->db.set(idType,sId);
            KC_GenID::Z_idGen result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        }
        printf("genId\n");
    
    }

    void getRangeId(Z_rangeId& _return, const std::string& idType, const int64_t rangeId) {
        // Your implementation goes here
        int32_t isExistKey =  this->db.check(idType);
        if (isExistKey < 0){
            int64_t id = rangeId;
            std::string sId = std::to_string(id);
            this->db.set(idType,sId);
            KC_GenID::Z_rangeId result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        } else {
            int64_t id;
            std::string sId;
            this->db.get(idType, &sId);
            id = std::stoi(sId);
            id+=rangeId;
            sId = std::to_string(id);
            this->db.set(idType,sId);
            KC_GenID::Z_rangeId result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        }
        printf("getRangeId\n");
    }

    void getIdValue(Z_idValue& _return, const std::string& idType) {
        // Your implementation goes here
        int32_t isExistKey =  this->db.check(idType);
        if (isExistKey < 0){
            int64_t id  = 0;
            KC_GenID::Z_idValue result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        } else {
            int64_t id;
            std::string sId;
            this->db.get(idType, &sId);
            id = std::stoi(sId);
            KC_GenID::Z_idValue result;
            result.errorCode = 0;
            result.data = id;
            _return =  result;
        }
        printf("getIdValue\n");
    }

};

class ZGenIDService : public Application {
public:

    ZGenIDService() : _helpRequested(false) {
        std::cout << "Start POCO Application Storage service..." << std::endl;
    }

protected:

    void 
    initialize(Application& self) {
        loadConfiguration(); // load default configuration files, if present
        Application::initialize(self);
        // add your own initialization code here
    }

    void 
    uninitialize() {
        // add your own uninitialization code here
        Application::uninitialize();
    }

    void 
    reinitialize(Application& self) {
        Application::reinitialize(self);
        // add your own reinitialization code here
    }

    void 
    defineOptions(OptionSet& options) {
        Application::defineOptions(options);

        options.addOption(
                Option("help", "h", "display help information on command line arguments")
                .required(false)
                .repeatable(false)
                .callback(OptionCallback<ZGenIDService>(this, &ZGenIDService::handleHelp)));

        options.addOption(
                Option("bind", "b", "bind option value to test.property")
                .required(false)
                .repeatable(false)
                .argument("value")
                .binding("test.property"));
    }

    void 
    handleHelp(const std::string& name, const std::string& value) {
        _helpRequested = true;
        displayHelp();
        stopOptionsProcessing();
    }

    void 
    displayHelp() {
        HelpFormatter helpFormatter(options());
        helpFormatter.setCommand(commandName());
        helpFormatter.setUsage("OPTIONS");
        helpFormatter.setHeader("A sample application that demonstrates some of the features of the Poco::Util::Application class.");
        helpFormatter.format(std::cout);
    }

    int 
    main(const ArgVec& args) {
        std::cout << "begin main" << std::endl;
        if (!_helpRequested) {
//            runService();
            runTNonblockingService();
        }
        return Application::EXIT_OK;
    }

private:
    bool        _helpRequested;
    int         _port;
    std::string _host;
    
    void 
    runService(){
        int port = 6789;
        shared_ptr<KC_GenIDHandler>     handler(new KC_GenIDHandler());
        shared_ptr<TProcessor>          processor(new KC_GenIDProcessor(handler));
        shared_ptr<TServerTransport>    serverTransport(new TServerSocket(port));
        shared_ptr<TTransportFactory>   transportFactory(new TBufferedTransportFactory());
        shared_ptr<TProtocolFactory>    protocolFactory(new TBinaryProtocolFactory());

        TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
        server.serve();
        return;
    }
    
    void
    runTNonblockingService() {
        std::cout << "runTNonblockingServer" << std::endl;
        int port = 6789;
        shared_ptr<KC_GenIDHandler>     handler(new KC_GenIDHandler());
        shared_ptr<TProcessor>          processor(new KC_GenIDProcessor(handler));
        shared_ptr<TServerTransport>    serverTransport(new TServerSocket(port));
        shared_ptr<TTransportFactory>   transportFactory(new TBufferedTransportFactory());
        shared_ptr<TProtocolFactory>    protocolFactory(new TBinaryProtocolFactory());

        shared_ptr<ThreadManager> threadManager         = ThreadManager::newSimpleThreadManager(8);
        shared_ptr<PosixThreadFactory> threadFactory    = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
        threadManager->threadFactory(threadFactory);
        threadManager->start();

        TNonblockingServer server(processor, protocolFactory, port, threadManager);
        server.serve();
        return;
    }
};

POCO_APP_MAIN(ZGenIDService)

